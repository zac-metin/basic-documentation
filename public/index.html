<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Basic Documentation</title>
</head>
<body>
  <div id="app"></div>
  <xmp theme="united" style="display:none;">

# Nock - Get Route Testing
```
test.cb('check artist id route', t => {
 const artistObj = {
   name: 'Izal',
   type: 'artist'
 }

 let scope = nock('https://api.spotify.com')
   .get('/v1/artists/2hazSY4Ef3aB9ATXW7F5w3')
   .reply(200, artistObj)

 request(app)
   .get('/api/v1/spotify/artists/2hazSY4Ef3aB9ATXW7F5w3')
   .expect(200)
   .then((res) => {
     scope.done()
     t.is(res.body.name, 'Izal')
     t.is(res.body.type, 'artist')
     t.end()
   })

})
```
When mocking a get route with Nock we first set up the mock route that is to be hit instead, configuring the get route and its response.

Once this is done we can attempt to hit our own get route. What we are testing in this case is that the get route API works correctly and hits the external API that we are trying to retrieve from.

The reason for this is that we will be running our tests often, and we do not want to actually hit the external API multiple times an hour.

### Example Code - Commented:
```
test.cb('check artist id route', t => {
 const artistObj = {
   name: 'Izal',
   type: 'artist'
 }

 // We create a fake response object called artistObj that our mock server is going to reply with.

 let scope = nock('https://api.spotify.com')
   .get('/v1/artists/2hazSY4Ef3aB9ATXW7F5w3')
   .reply(200, artistObj)

   // These three lines set up our mocked external API. This means that when our test function tries to hit api.spotify.com at the specified get route
   // Nock will intercept it and reply with the status code 200 and artistObj.

 request(app)
   .get('/api/v1/spotify/artists/2hazSY4Ef3aB9ATXW7F5w3')
   .expect(200)
   .then((res) => {
     scope.done()
     t.is(res.body.name, 'Izal')
     t.is(res.body.type, 'artist')
     t.end()
   })

   // From here we can just initiate a normal get request via superagent and Nock will intercept and respond as we set it to.

})

Post route testing with Nock is almost identical to Get route testing, as you can see below.

```
# Nock - Post Route Testing
```
test.cb('check createPlaylist post route', t => {
let scope = nock('https://api.spotify.com')
  .post(`/v1/users/some_username/playlists`)
  .reply(201, {test: "73a"})
let token = createToken({id: "some_username"}, app.get('JWT_SECRET'))
  request(app)
    .post('/api/v1/spotify/users/playlist')
    .set('Cookie', `token=${token}`)
    .then((result) => {
      scope.done()
      t.is(result.body.test, "73a")
      t.end()
    })
})
```
When mocking a post route with Nock we first set up the mock route that is to be hit instead, configuring the post route and its response.

Once this is done we can attempt to hit our own post route API. What we are testing in this case is that the post route API works correctly and hits the external API that we are posting to.

### Example Code - Commented:
```
test.cb('check createPlaylist post route', t => {

let scope = nock('https://api.spotify.com')
  .post(`/v1/users/some_username/playlists`)
  .reply(201, {test: "73a"})

// These three lines set up our mocked external API. This means that when our test function tries to hit api.spotify.com at the specified post route
// Nock will intercept it and reply with the status code and response object that we tell it to on the line above.

  let token = createToken({id: "some_username"}, app.get('JWT_SECRET'))

// Because we are dealing with an authenticated route, this line will take care of creating an authentication token for us

// From now on we just test as we normally would with Supertest, save for the scope.done() which will hang if the API request does not complete.

  request(app)
    .post('/api/v1/spotify/users/playlist')
    .set('Cookie', `token=${token}`)
    .then((result) => {
      scope.done()
      t.is(result.body.test, "73a")
      t.end()
    })
})
```




  </xmp>

  <script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
  <script src="bundle.js"></script>
</body>
</html>
